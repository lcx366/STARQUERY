import numpy as np
import pandas as pd
import healpy as hp

from .catalog_index import find_healpix_level,get_k5_indices,fetch_stars_from_k5_indices
from .utils.math import separation
from .astrometry_corrections import apply_astrometry_corrections

def search_box_simplified(radec_box, dir_sc, sc_name, indices_path, lvl, max_num_per_tile, astrometry_corrections={}):
    """
    This function performs a rectangular search of stars in specified simplified star catalogs within a given RA/Dec box.
    It applies various astrometry corrections based on the input parameters.

    Inputs:
        radec_box -> [array-like] Rectangular search area in form of [ra_min, dec_min, ra_max, dec_max] in degrees.
        dir_sc -> [str] Path of star catalog tile files.
        sc_name -> [str] Name of the star catalog.
        indices_path -> [str] Path to the star catalog index file (generated by build_catalog_indices).
        lvl -> [int] The healpix order which determines the hierarchical division of the sky region.
        ensuring that each tile's size is greater than one-quarter of the FOV and less than or equal to half of the FOV.
        max_num_per_tile -> [int] Maximum number of stars to include in each tile, sorted by brightness. If None, includes all stars meeting the criteria.
        astrometry_corrections -> [dict, optional, default={}] Dictionary specifying the types of astrometry corrections to apply.
            - 't' -> [str] Observation time in UTC, such as '2019-02-26T20:11:14.347'.
            - 'proper-motion' -> [None] If present, apply proper motion correction.
            - 'aberration' -> [tuple] Aberration correction parameters. Observer's velocity relative to Earth's center (vx, vy, vz) in km/s.
            - 'parallax' -> [None] If present, apply parallax correction.
            - 'deflection' -> [None] If present, apply light deflection correction.
    Outputs:
        df -> [pd.DataFrame] DataFrame containing stars within the rectangular search area.
        level -> [str] HEALPix level used for the search.
        nside -> [int] NSIDE parameter of the HEALPix grid used for the search.
        ids -> [list] List of HEALPix pixel IDs covered by the search box.
        pixel_size -> [float] Approximate size of each HEALPix pixel in degrees.
    """
    ra_min, dec_min, ra_max, dec_max = radec_box
    dec_c,ra_c = np.mean([dec_max,dec_min]),np.mean([ra_max,ra_min])
    ra_range,dec_range = ra_max-ra_min,dec_max-dec_min

    vertices = np.array([
        [ra_min, dec_min],  # Bottom left
        [ra_max, dec_min],  # Bottom right
        [ra_max, dec_max],  # Top right
        [ra_min, dec_max]   # Top left
    ])

    # Convert the vertices from spherical coordinates (RA, Dec) to 3D Cartesian coordinates (x, y, z)
    # The input 'vertices' is assumed to have shape (N, 2), where:
    #   - vertices[:, 0] represents the longitude (Right Ascension, RA)
    #   - vertices[:, 1] represents the latitude (Declination, Dec)
    # The 'lonlat=True' flag indicates that the input coordinates are in degrees (longitude, latitude)
    vertices_uec = hp.ang2vec(vertices[:,0],vertices[:,1],lonlat=True)

    # Round the 3D Cartesian coordinates to a specified precision (5 decimal places)
    # This rounding step helps in reducing minor numerical differences between very close coordinates,
    # especially useful when coordinates are near the poles where small differences in longitude (RA)
    # can cause almost identical Cartesian coordinates.
    vertices_uec_rounded = np.round(vertices_uec, decimals=5)

    # Use 'np.unique' to find unique rows in the rounded array, while preserving the original order.
    # This step helps eliminate nearly identical rows caused by numerical precision errors,
    # which can prevent issues like degenerate polygons in spherical queries.
    _, idx = np.unique(vertices_uec_rounded, axis=0, return_index=True)
    # Sorting the indices ensures the original order of the vertices is maintained.
    vertices_uec = vertices_uec[np.sort(idx)]

    # Find the HEALPix order for a given search area
    if lvl > 99:
        fov_min = min(ra_range, dec_range)
        level, nside, npix, pixel_size = find_healpix_level(fov_min=fov_min)
    else:
        level, nside, npix, pixel_size = find_healpix_level(lvl=lvl)

    # Query the HEALPix pixels covered by the search box
    ids = hp.query_polygon(nside, vertices_uec, inclusive=True,fact=64,nest=True)

    # Maps a list of pixel IDs at a given HEALPix query level (K1–K11) to their corresponding K5-level pixel IDs and sub-index ranges.
    k5_indices_list = get_k5_indices(indices_path, level, ids)
    # Fetches star records from a dictionary returned by get_k5_indices().
    df = fetch_stars_from_k5_indices(k5_indices_list, dir_sc, sc_name, max_num_per_tile)

    if df.empty: 
        return df,level,nside,ids,pixel_size

    # Ensure required columns are numeric
    required_columns = ['ra', 'dec', 'mag', 'epoch']
    pm_columns = ['pm_ra', 'pm_dec']
    dist_columns = ['dist']

    if set(pm_columns).issubset(df.columns):
        required_columns.extend(pm_columns)
    if set(dist_columns).issubset(df.columns):
        required_columns.extend(dist_columns)

    df[required_columns] = df[required_columns].apply(pd.to_numeric, errors='coerce')

    # Filter stars within the search box
    ra_flag = np.abs(df['ra'] - ra_c) < ra_range / 2
    dec_flag = np.abs(df['dec'] - dec_c) < dec_range / 2
    df = df[ra_flag & dec_flag]

    ra_rad, dec_rad = np.radians(df[['ra', 'dec']].values).T

    if astrometry_corrections:
        df = apply_astrometry_corrections(df, astrometry_corrections, ra_rad, dec_rad)

    df.reset_index(drop=True, inplace=True)

    return df,level,nside,ids,pixel_size

def search_cone_simplified(center, radius, dir_sc, sc_name, indices_path, lvl, max_num_per_tile, astrometry_corrections={}):
    """
    This function performs a cone search of stars in specified simplified star catalogs within a given RA/Dec center and radius.
    It applies various astrometry corrections based on the input parameters.

    Inputs:
        center -> [list] Center of the cap in form of [Ra, Dec] in degrees.
        radius -> [float] Angular radius of the cap in degrees.
        dir_sc -> [str] Directory of the star catalog tile files.
        sc_name -> [str] Name of the star catalog.
        indices_path -> [str] Path to the star catalog index file (generated by build_catalog_indices).
        lvl -> [int] The healpix order which determines the hierarchical division of the sky region.
        ensuring that each tile's size is greater than one-quarter of the FOV and less than or equal to half of the FOV.
        max_num_per_tile -> [int] Maximum number of stars to include in each tile, sorted by brightness. If None, includes all stars meeting the criteria.
        astrometry_corrections -> [dict, optional, default={}] Dictionary specifying the types of astrometry corrections to apply.
            - 't' -> [str] Observation time in UTC, such as '2019-02-26T20:11:14.347'.
            - 'proper-motion' -> [None] If present, apply proper motion correction.
            - 'aberration' -> [tuple] Aberration correction parameters. Observer's velocity relative to Earth's center (vx, vy, vz) in km/s.
            - 'parallax' -> [None] If present, apply parallax correction.
            - 'deflection' -> [None] If present, apply light deflection correction.
    Returns:
        df -> [pd.DataFrame] DataFrame containing stars within the cone search area.
        level -> [str] HEALPix level used for the search.
        nside -> [int] NSIDE parameter of the HEALPix grid used for the search.
        ids -> [list] List of HEALPix pixel IDs covered by the search cone.
        pixel_size -> [float] Approximate size of each HEALPix pixel in degrees.
    """
    # Extract center coordinates for the cone search
    ra_c, dec_c = center

    # Find the HEALPix order for a given search area
    if lvl > 99:
        level, nside, npix, pixel_size = find_healpix_level(fov_min=radius*2)
    else:
        level, nside, npix, pixel_size = find_healpix_level(lvl=lvl)

    # Compute the unit vector for the cone center
    uec = hp.ang2vec(ra_c, dec_c, lonlat=True)

    # Query the HEALPix pixels covering the cone
    ids = hp.query_disc(nside, uec, np.radians(radius), inclusive=True,fact=64, nest=True)

    # Maps a list of pixel IDs at a given HEALPix query level (K1–K11) to their corresponding K5-level pixel IDs and sub-index ranges.
    k5_indices_list = get_k5_indices(indices_path, level, ids)
    # Fetches star records from a dictionary returned by get_k5_indices().
    df = fetch_stars_from_k5_indices(k5_indices_list, dir_sc, sc_name, max_num_per_tile)

    if df.empty: 
        return df,level,nside,ids,pixel_size

    # Ensure required columns are numeric
    required_columns = ['ra', 'dec', 'mag', 'epoch']
    pm_columns = ['pm_ra', 'pm_dec']
    dist_columns = ['dist']

    if set(pm_columns).issubset(df.columns):
        required_columns.extend(pm_columns)
    if set(dist_columns).issubset(df.columns):
        required_columns.extend(dist_columns)

    df[required_columns] = df[required_columns].apply(pd.to_numeric, errors='coerce')

    # Calculate the angular distance between the cap center and each grid point.
    ra_c_rad,dec_c_rad = np.radians([ra_c,dec_c])
    ra_rad,dec_rad = np.radians(df[['ra', 'dec']].values).T
    angular_distance_cos = separation(ra_c_rad,dec_c_rad,ra_rad,dec_rad)
    # Determine whether each grid point is inside the cap.
    inside_cone = angular_distance_cos >= np.cos(np.deg2rad(radius))
    df = df[inside_cone]
    ra_rad, dec_rad = ra_rad[inside_cone], dec_rad[inside_cone]

    if astrometry_corrections:
        df = apply_astrometry_corrections(df, astrometry_corrections, ra_rad, dec_rad)

    df.reset_index(drop=True, inplace=True)

    return df,level,nside,ids,pixel_size